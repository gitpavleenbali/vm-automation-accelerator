# Azure DevOps Pipeline Template: Script Execution (Windows)
# Reusable template for executing VM Automation deployment scripts on Windows agents
# Uses PowerShell instead of bash for Windows compatibility

parameters:
  - name: scriptPath
    type: string
    displayName: 'Path to deployment script (relative to repo root)'
  
  - name: scriptName
    type: string
    displayName: 'Friendly name for the script (for logging)'
  
  - name: environment
    type: string
    displayName: 'Target environment (dev, uat, prod)'
    default: 'dev'
  
  - name: workspacePrefix
    type: string
    displayName: 'Workspace prefix for VM naming'
    default: ''
  
  - name: deploymentMode
    type: string
    displayName: 'Deployment mode'
    default: 'bootstrap'
    values:
      - bootstrap  # Local state (initial deployment)
      - run        # Remote state (production deployment)
  
  - name: action
    type: string
    displayName: 'Deployment action'
    default: 'deploy'
    values:
      - deploy
      - destroy
      - validate
  
  - name: additionalArgs
    type: string
    displayName: 'Additional arguments to pass to script'
    default: ''
  
  - name: azureServiceConnection
    type: string
    displayName: 'Azure service connection name'
  
  - name: workingDirectory
    type: string
    displayName: 'Working directory for script execution'
    default: '$(System.DefaultWorkingDirectory)'
  
  - name: skipValidation
    type: boolean
    displayName: 'Skip pre-deployment validation'
    default: false
  
  - name: cleanupOnFailure
    type: boolean
    displayName: 'Run cleanup on failure'
    default: true
  
  - name: publishArtifacts
    type: boolean
    displayName: 'Publish deployment artifacts'
    default: true

  - name: validateOnly
    type: boolean
    displayName: 'Validation only mode'
    default: false

steps:
  # ========================================
  # Step 1: Pre-execution Validation
  # ========================================
  - task: AzureCLI@2
    displayName: 'Pre-execution Validation - ${{ parameters.scriptName }}'
    condition: and(succeeded(), eq(${{ parameters.skipValidation }}, false))
    inputs:
      azureSubscription: ${{ parameters.azureServiceConnection }}
      scriptType: 'pscore'
      scriptLocation: 'inlineScript'
      workingDirectory: ${{ parameters.workingDirectory }}
      inlineScript: |
        Write-Host "=============================================="
        Write-Host "Pre-execution Validation: ${{ parameters.scriptName }}"
        Write-Host "=============================================="
        
        # Check script exists
        if (-not (Test-Path "${{ parameters.scriptPath }}")) {
          Write-Host "##vso[task.logissue type=error]Script not found: ${{ parameters.scriptPath }}"
          exit 1
        }
        
        # Validate environment parameter
        if ("${{ parameters.environment }}" -notin @("dev", "uat", "prod")) {
          Write-Host "##vso[task.logissue type=error]Invalid environment: ${{ parameters.environment }}"
          exit 1
        }
        
        # Check Azure CLI authentication
        Write-Host "Verifying Azure CLI authentication..."
        try {
          $account = az account show | ConvertFrom-Json
          Write-Host "Connected to subscription: $($account.name) ($($account.id))"
        }
        catch {
          Write-Host "##vso[task.logissue type=error]Azure CLI authentication failed"
          exit 1
        }
        
        # Check Terraform version
        try {
          $terraformVersion = terraform version -json | ConvertFrom-Json
          Write-Host "Terraform version: $($terraformVersion.terraform_version)"
        }
        catch {
          Write-Host "##vso[task.logissue type=warning]Terraform not found in PATH"
        }
        
        Write-Host "Pre-execution validation completed successfully"

  # ========================================
  # Step 2: Execute PowerShell Deployment Script
  # ========================================
  - task: AzureCLI@2
    displayName: 'Execute Deployment - ${{ parameters.scriptName }}'
    timeoutInMinutes: 30
    inputs:
      azureSubscription: ${{ parameters.azureServiceConnection }}
      scriptType: 'pscore'
      scriptLocation: 'inlineScript'
      workingDirectory: ${{ parameters.workingDirectory }}
      inlineScript: |
        Write-Host "=============================================="
        Write-Host "Executing: ${{ parameters.scriptName }}"
        Write-Host "=============================================="
        
        # Set error handling
        $ErrorActionPreference = "Stop"
        
        # Set deployment parameters
        $env:ENVIRONMENT = "${{ parameters.environment }}"
        $env:WORKSPACE_PREFIX = "${{ parameters.workspacePrefix }}"
        $env:DEPLOYMENT_MODE = "${{ parameters.deploymentMode }}"
        $env:ACTION = "${{ parameters.action }}"
        
        # Get Azure context
        $account = az account show | ConvertFrom-Json
        $env:ARM_SUBSCRIPTION_ID = $account.id
        $env:ARM_TENANT_ID = $account.tenantId
        
        Write-Host "Environment: ${{ parameters.environment }}"
        Write-Host "Workspace Prefix: ${{ parameters.workspacePrefix }}"
        Write-Host "Deployment Mode: ${{ parameters.deploymentMode }}"
        Write-Host "Action: ${{ parameters.action }}"
        Write-Host "Subscription: $($account.name)"
        
        # Execute the PowerShell deployment script
        try {
          $validateOnlyFlag = if ('${{ parameters.validateOnly }}' -eq 'True') { '-ValidateOnly' } else { '' }
          
          if ("${{ parameters.scriptName }}" -eq "control-plane") {
            Write-Host "Executing Control Plane deployment..."
            Invoke-Expression "& `".\Deploy-VMAutomationAccelerator.ps1`" -Environment `"${{ parameters.environment }}`" -SkipWorkloadZone $validateOnlyFlag -Verbose"
          }
          elseif ("${{ parameters.scriptName }}" -eq "workload-zone") {
            Write-Host "Executing Workload Zone deployment..."
            Invoke-Expression "& `".\Deploy-VMAutomationAccelerator.ps1`" -Environment `"${{ parameters.environment }}`" -SkipControlPlane $validateOnlyFlag -Verbose"
          }
          elseif ("${{ parameters.scriptName }}" -eq "vm-deployment") {
            Write-Host "Executing VM deployment..."
            Invoke-Expression "& `".\Deploy-VMAutomationAccelerator.ps1`" -Environment `"${{ parameters.environment }}`" -SkipControlPlane -SkipWorkloadZone $validateOnlyFlag -Verbose"
          }
          else {
            Write-Host "Executing full deployment..."
            Invoke-Expression "& `".\Deploy-VMAutomationAccelerator.ps1`" -Environment `"${{ parameters.environment }}`" $validateOnlyFlag -Verbose"
          }
          
          Write-Host "Deployment completed successfully"
        }
        catch {
          Write-Host "##vso[task.logissue type=error]Deployment failed: $($_.Exception.Message)"
          if ('${{ parameters.cleanupOnFailure }}' -eq 'True') {
            Write-Host "Running cleanup on failure..."
            # Add cleanup logic here if needed
          }
          throw
        }

  # ========================================
  # Step 3: Create and Publish Artifacts
  # ========================================
  - task: PowerShell@2
    displayName: 'Prepare Deployment Artifacts - ${{ parameters.scriptName }}'
    condition: and(always(), eq(${{ parameters.publishArtifacts }}, true))
    inputs:
      targetType: 'inline'
      workingDirectory: ${{ parameters.workingDirectory }}
      script: |
        Write-Host "Preparing deployment artifacts for ${{ parameters.scriptName }}..."
        
        # Create terraform-output directory (match expected path)
        $artifactsDir = "terraform-output"
        if (-not (Test-Path $artifactsDir)) {
          New-Item -ItemType Directory -Path $artifactsDir -Force | Out-Null
          Write-Host "Created terraform-output directory: $artifactsDir"
        } else {
          Write-Host "Terraform-output directory already exists: $artifactsDir"
        }
        
        # Copy deployment results JSON files
        $deploymentResults = Get-ChildItem -Path "." -Filter "deployment-results-*.json" -ErrorAction SilentlyContinue
        if ($deploymentResults) {
          foreach ($file in $deploymentResults) {
            Copy-Item $file.FullName "$artifactsDir/" -Force
            Write-Host "Copied: $($file.Name)"
          }
        } else {
          Write-Host "No deployment-results-*.json files found"
        }
        
        # Copy pipeline summary files  
        $summaryFiles = Get-ChildItem -Path "." -Filter "pipeline-deployment-summary-*.json" -ErrorAction SilentlyContinue
        if ($summaryFiles) {
          foreach ($file in $summaryFiles) {
            Copy-Item $file.FullName "$artifactsDir/" -Force
            Write-Host "Copied: $($file.Name)"
          }
        }
        
        # Copy Terraform plan files
        $planFiles = Get-ChildItem -Path "." -Filter "*.tfplan" -Recurse -ErrorAction SilentlyContinue
        if ($planFiles) {
          foreach ($file in $planFiles) {
            $destPath = Join-Path $artifactsDir $file.Name
            Copy-Item $file.FullName $destPath -Force
            Write-Host "Copied plan file: $($file.Name)"
          }
        } else {
          Write-Host "No .tfplan files found"
        }
        
        # Copy any terraform output logs
        $tfLogs = Get-ChildItem -Path "." -Filter "*terraform*.log" -Recurse -ErrorAction SilentlyContinue
        if ($tfLogs) {
          foreach ($file in $tfLogs) {
            $destPath = Join-Path $artifactsDir $file.Name
            Copy-Item $file.FullName $destPath -Force
            Write-Host "Copied log file: $($file.Name)"
          }
        }
        
        # Create deployment summary if not exists
        $summaryPath = Join-Path $artifactsDir "deployment-summary.json"
        if (-not (Test-Path $summaryPath)) {
          $summary = @{
            deploymentName = "${{ parameters.scriptName }}"
            environment = "${{ parameters.environment }}"
            workspacePrefix = "${{ parameters.workspacePrefix }}"
            deploymentMode = "${{ parameters.deploymentMode }}"
            action = "${{ parameters.action }}"
            timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss UTC"
            buildId = "$(Build.BuildId)"
            buildNumber = "$(Build.BuildNumber)"
          } | ConvertTo-Json -Depth 10
          
          $summary | Out-File $summaryPath -Force
          Write-Host "Created deployment summary: deployment-summary.json"
        }
        
        # List all artifacts
        Write-Host "`nArtifacts prepared in terraform-output:"
        if (Test-Path $artifactsDir) {
          Get-ChildItem $artifactsDir | ForEach-Object { Write-Host "  - $($_.Name) ($($_.Length) bytes)" }
        } else {
          Write-Host "  ERROR: terraform-output directory does not exist!"
        }

  - task: PublishBuildArtifacts@1
    displayName: 'Publish Deployment Artifacts - ${{ parameters.scriptName }}'
    condition: and(always(), eq(${{ parameters.publishArtifacts }}, true))
    inputs:
      PathtoPublish: 'terraform-output'
      ArtifactName: '${{ parameters.scriptName }}-deployment-artifacts'
      publishLocation: 'Container'
    continueOnError: true

  # ========================================
  # Step 4: Deployment Summary
  # ========================================
  - task: AzureCLI@2
    displayName: 'Deployment Summary - ${{ parameters.scriptName }}'
    condition: always()
    inputs:
      azureSubscription: ${{ parameters.azureServiceConnection }}
      scriptType: 'pscore'
      scriptLocation: 'inlineScript'
      workingDirectory: ${{ parameters.workingDirectory }}
      inlineScript: |
        Write-Host "=============================================="
        Write-Host "Deployment Summary: ${{ parameters.scriptName }}"
        Write-Host "=============================================="
        Write-Host "Environment: ${{ parameters.environment }}"
        Write-Host "Workspace Prefix: ${{ parameters.workspacePrefix }}"
        Write-Host "Status: $(if ($env:AGENT_JOBSTATUS -eq 'Succeeded') { 'SUCCESS' } else { 'FAILED' })"
        Write-Host "=============================================="