# Azure DevOps Pipeline for Terraform VM Deployment
# Production-ready pipeline with state management, plan/apply workflow, and approval gates
# Supports multi-environment deployments (Dev, UAT, Prod)

trigger:
  branches:
    include:
      - main
      - develop
  paths:
    include:
      - iac/terraform/**
      - pipelines/azure-devops/terraform-vm-deploy-pipeline.yml

pr:
  branches:
    include:
      - main
      - develop
  paths:
    include:
      - iac/terraform/**

parameters:
  - name: environment
    displayName: 'Target Environment'
    type: string
    default: 'dev'
    values:
      - dev
      - uat
      - prod
  
  - name: action
    displayName: 'Terraform Action'
    type: string
    default: 'plan'
    values:
      - plan
      - apply
      - destroy

variables:
  - group: vm-automation-secrets-${{ parameters.environment }}  # Environment-specific variable group
  - name: terraformVersion
    value: '1.5.7'
  - name: environment
    value: ${{ parameters.environment }}
  - name: azureServiceConnection
    value: 'azure-${{ parameters.environment }}-service-connection'
  - name: backendStorageAccount
    value: 'sttfstate${{ parameters.environment }}001'  # Update with your storage account
  - name: backendContainer
    value: 'tfstate'
  - name: backendResourceGroup
    value: 'rg-terraform-state-${{ parameters.environment }}'
  - name: backendKey
    value: 'vm-automation-${{ parameters.environment }}.tfstate'
  - name: tfvarsFile
    value: 'environments/${{ parameters.environment }}.tfvars'
  - name: workingDirectory
    value: '$(System.DefaultWorkingDirectory)/iac/terraform'

pool:
  vmImage: 'ubuntu-latest'

stages:
  # ========================================
  # STAGE 1: Initialize Terraform Backend
  # ========================================
  - stage: InitializeTerraformBackend
    displayName: 'Initialize Terraform Backend'
    jobs:
      - job: ValidateBackend
        displayName: 'Validate and Initialize Backend'
        steps:
          - checkout: self
          
          - task: AzureCLI@2
            displayName: 'Ensure Backend Storage Account Exists'
            inputs:
              azureSubscription: $(azureServiceConnection)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "Checking if backend storage account exists..."
                
                # Check if resource group exists
                if ! az group show --name $(backendResourceGroup) &>/dev/null; then
                  echo "Creating resource group $(backendResourceGroup)..."
                  az group create --name $(backendResourceGroup) --location westeurope
                fi
                
                # Check if storage account exists
                if ! az storage account show --name $(backendStorageAccount) --resource-group $(backendResourceGroup) &>/dev/null; then
                  echo "Creating storage account $(backendStorageAccount)..."
                  az storage account create \
                    --name $(backendStorageAccount) \
                    --resource-group $(backendResourceGroup) \
                    --location westeurope \
                    --sku Standard_LRS \
                    --kind StorageV2 \
                    --https-only true \
                    --min-tls-version TLS1_2 \
                    --allow-blob-public-access false
                  
                  # Enable versioning for state file protection
                  az storage account blob-service-properties update \
                    --account-name $(backendStorageAccount) \
                    --enable-versioning true
                fi
                
                # Check if container exists
                if ! az storage container show --name $(backendContainer) --account-name $(backendStorageAccount) &>/dev/null; then
                  echo "Creating container $(backendContainer)..."
                  az storage container create \
                    --name $(backendContainer) \
                    --account-name $(backendStorageAccount) \
                    --auth-mode login
                fi
                
                echo "Backend storage initialized successfully"

  # ========================================
  # STAGE 2: Terraform Validate and Plan
  # ========================================
  - stage: TerraformPlan
    displayName: 'Terraform Plan'
    dependsOn: InitializeTerraformBackend
    jobs:
      - job: ValidateAndPlan
        displayName: 'Validate Configuration and Generate Plan'
        steps:
          - checkout: self
          
          - task: TerraformInstaller@0
            displayName: 'Install Terraform'
            inputs:
              terraformVersion: $(terraformVersion)
          
          - task: AzureCLI@2
            displayName: 'Terraform Init'
            inputs:
              azureSubscription: $(azureServiceConnection)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              workingDirectory: $(workingDirectory)
              inlineScript: |
                echo "Initializing Terraform..."
                
                # Get environment from branch or variable
                if [[ "$(Build.SourceBranchName)" == "main" ]]; then
                  ENVIRONMENT="prod"
                else
                  ENVIRONMENT="dev"
                fi
                
                echo "Environment: $ENVIRONMENT"
                
                # Initialize with backend configuration
                terraform init \
                  -backend-config="backend-config/${ENVIRONMENT}.hcl" \
                  -upgrade
                
                echo "Terraform initialized successfully"
          
          - task: AzureCLI@2
            displayName: 'Terraform Validate'
            inputs:
              azureSubscription: $(azureServiceConnection)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              workingDirectory: $(workingDirectory)
              inlineScript: |
                echo "Validating Terraform configuration..."
                terraform validate
                echo "Validation successful"
          
          - task: AzureCLI@2
            displayName: 'Terraform Format Check'
            inputs:
              azureSubscription: $(azureServiceConnection)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              workingDirectory: $(workingDirectory)
              inlineScript: |
                echo "Checking Terraform formatting..."
                if ! terraform fmt -check -recursive; then
                  echo "##vso[task.logissue type=warning]Terraform files are not formatted correctly. Run 'terraform fmt -recursive' locally."
                fi
          
          - task: PowerShell@2
            displayName: 'Run Security Compliance Check (Checkov)'
            inputs:
              targetType: 'inline'
              script: |
                Write-Host "Installing Checkov for security scanning..."
                pip install checkov
                
                Write-Host "Running Checkov security scan..."
                checkov -d $(workingDirectory) --framework terraform --output junitxml --output-file-path $(Build.ArtifactStagingDirectory)/checkov-report.xml || true
              workingDirectory: $(workingDirectory)
          
          - task: PublishTestResults@2
            displayName: 'Publish Checkov Results'
            condition: always()
            inputs:
              testResultsFormat: 'JUnit'
              testResultsFiles: '$(Build.ArtifactStagingDirectory)/checkov-report.xml'
              testRunTitle: 'Checkov Security Scan'
          
          - task: PowerShell@2
            displayName: 'Validate Quota Availability'
            inputs:
              targetType: 'filePath'
              filePath: '$(System.DefaultWorkingDirectory)/scripts/powershell/Validate-Quota.ps1'
              arguments: >
                -SubscriptionId "$(ARM_SUBSCRIPTION_ID)"
                -Location "$(TF_VAR_location)"
                -VMSize "$(TF_VAR_vm_size)"
                -Quantity 1
          
          - task: PowerShell@2
            displayName: 'Generate Cost Forecast'
            inputs:
              targetType: 'filePath'
              filePath: '$(System.DefaultWorkingDirectory)/scripts/powershell/Get-CostForecast.ps1'
              arguments: >
                -SubscriptionId "$(ARM_SUBSCRIPTION_ID)"
                -VMSize "$(TF_VAR_vm_size)"
                -DataDisks @(512,1024)
                -Region "$(TF_VAR_location)"
                -OutputPath "$(Build.ArtifactStagingDirectory)/cost-forecast.json"
          
          - task: AzureCLI@2
            displayName: 'Terraform Plan'
            inputs:
              azureSubscription: $(azureServiceConnection)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              workingDirectory: $(workingDirectory)
              inlineScript: |
                echo "Generating Terraform plan..."
                
                # Get environment
                if [[ "$(Build.SourceBranchName)" == "main" ]]; then
                  ENVIRONMENT="prod"
                else
                  ENVIRONMENT="dev"
                fi
                
                # Fetch secrets from Key Vault
                DOMAIN_JOIN_PASSWORD=$(az keyvault secret show --name "domain-join-password" --vault-name "$(KEY_VAULT_NAME)" --query value -o tsv)
                STORAGE_ACCOUNT_KEY=$(az keyvault secret show --name "scripts-storage-key" --vault-name "$(KEY_VAULT_NAME)" --query value -o tsv)
                
                # Export Terraform variables
                export TF_VAR_domain_join_password="$DOMAIN_JOIN_PASSWORD"
                export TF_VAR_scripts_storage_account_key="$STORAGE_ACCOUNT_KEY"
                
                # Set environment
                ENVIRONMENT="$(environment)"
                
                # Generate plan with environment-specific tfvars
                terraform plan \
                  -var-file="$(tfvarsFile)" \
                  -out="$(Build.ArtifactStagingDirectory)/tfplan" \
                  -detailed-exitcode || true
                
                PLAN_EXIT_CODE=$?
                
                if [ $PLAN_EXIT_CODE -eq 0 ]; then
                  echo "No changes detected"
                  echo "##vso[task.setvariable variable=terraformChanges;isOutput=true]false"
                elif [ $PLAN_EXIT_CODE -eq 2 ]; then
                  echo "Changes detected"
                  echo "##vso[task.setvariable variable=terraformChanges;isOutput=true]true"
                else
                  echo "Terraform plan failed"
                  exit 1
                fi
            name: planStep
          
          - task: AzureCLI@2
            displayName: 'Generate Human-Readable Plan'
            inputs:
              azureSubscription: $(azureServiceConnection)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              workingDirectory: $(workingDirectory)
              inlineScript: |
                echo "Generating human-readable plan output..."
                terraform show -no-color "$(Build.ArtifactStagingDirectory)/tfplan" > "$(Build.ArtifactStagingDirectory)/tfplan.txt"
                
                # Extract resource changes summary
                echo "=== Terraform Plan Summary ===" | tee "$(Build.ArtifactStagingDirectory)/plan-summary.txt"
                terraform show -json "$(Build.ArtifactStagingDirectory)/tfplan" | jq -r '.resource_changes[] | "\(.change.actions[0]) \(.type).\(.name)"' | tee -a "$(Build.ArtifactStagingDirectory)/plan-summary.txt"
          
          - task: PublishPipelineArtifact@1
            displayName: 'Publish Terraform Plan'
            inputs:
              targetPath: '$(Build.ArtifactStagingDirectory)'
              artifact: 'terraform-plan'
              publishLocation: 'pipeline'

  # ========================================
  # STAGE 3: L2 Approval Gate (Prod Only)
  # ========================================
  - stage: L2Approval
    displayName: 'L2 Approval Gate'
    dependsOn: TerraformPlan
    condition: and(succeeded(), eq(variables['Build.SourceBranchName'], 'main'), eq(dependencies.TerraformPlan.outputs['ValidateAndPlan.planStep.terraformChanges'], 'true'))
    jobs:
      - job: WaitForApproval
        displayName: 'Wait for L2 Approval'
        pool: server
        steps:
          - task: ManualValidation@0
            displayName: 'Manual Approval Required'
            inputs:
              notifyUsers: 'l2-approvers@Your Organization.com'
              instructions: |
                Please review the Terraform plan in the artifacts section.
                
                **Plan Summary:**
                - Download and review tfplan.txt
                - Check cost-forecast.json for estimated costs
                - Review checkov security scan results
                
                **Approval Required For:**
                - VM Deployment: $(TF_VAR_vm_name)
                - Environment: Production
                - Cost Impact: See cost-forecast.json
                
                Approve only if the plan looks correct.
              onTimeout: 'reject'
      
      - job: UpdateServiceNowTicket
        displayName: 'Update ServiceNow Ticket - Approved'
        dependsOn: WaitForApproval
        steps:
          - checkout: self
          
          - task: PowerShell@2
            displayName: 'Update ServiceNow - L2 Approved'
            inputs:
              targetType: 'filePath'
              filePath: '$(System.DefaultWorkingDirectory)/scripts/powershell/Update-ServiceNowTicket.ps1'
              arguments: >
                -TicketNumber "$(SERVICENOW_TICKET)"
                -Status "Approved - Deploying"
                -Comments "L2 approval received. Terraform plan approved. Proceeding with deployment."
                -ServiceNowInstance "$(SERVICENOW_INSTANCE)"
                -ServiceNowUser "$(SERVICENOW_USER)"
                -ServiceNowPassword "$(SERVICENOW_PASSWORD)"

  # ========================================
  # STAGE 4: Terraform Apply
  # ========================================
  - stage: TerraformApply
    displayName: 'Terraform Apply'
    dependsOn: 
      - TerraformPlan
      - L2Approval
    condition: |
      and(
        succeeded(),
        or(
          eq(variables['Build.SourceBranchName'], 'develop'),
          and(
            eq(variables['Build.SourceBranchName'], 'main'),
            succeeded('L2Approval')
          )
        ),
        eq(dependencies.TerraformPlan.outputs['ValidateAndPlan.planStep.terraformChanges'], 'true')
      )
    jobs:
      - deployment: DeployInfrastructure
        displayName: 'Deploy Infrastructure'
        environment: 'vm-automation-production'
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self
                
                - task: DownloadPipelineArtifact@2
                  displayName: 'Download Terraform Plan'
                  inputs:
                    artifactName: 'terraform-plan'
                    targetPath: '$(Pipeline.Workspace)/terraform-plan'
                
                - task: TerraformInstaller@0
                  displayName: 'Install Terraform'
                  inputs:
                    terraformVersion: $(terraformVersion)
                
                - task: AzureCLI@2
                  displayName: 'Terraform Init'
                  inputs:
                    azureSubscription: $(azureServiceConnection)
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    workingDirectory: $(workingDirectory)
                    inlineScript: |
                      echo "Initializing Terraform..."
                      
                      # Use environment from pipeline parameter
                      ENVIRONMENT="$(environment)"
                      
                      terraform init -backend-config="backend-config/${ENVIRONMENT}.hcl"
                
                - task: AzureCLI@2
                  displayName: 'Terraform Apply'
                  inputs:
                    azureSubscription: $(azureServiceConnection)
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    workingDirectory: $(workingDirectory)
                    inlineScript: |
                      echo "Applying Terraform plan..."
                      
                      # Fetch secrets
                      DOMAIN_JOIN_PASSWORD=$(az keyvault secret show --name "domain-join-password" --vault-name "$(KEY_VAULT_NAME)" --query value -o tsv)
                      STORAGE_ACCOUNT_KEY=$(az keyvault secret show --name "scripts-storage-key" --vault-name "$(KEY_VAULT_NAME)" --query value -o tsv)
                      
                      export TF_VAR_domain_join_password="$DOMAIN_JOIN_PASSWORD"
                      export TF_VAR_scripts_storage_account_key="$STORAGE_ACCOUNT_KEY"
                      
                      # Apply the plan
                      terraform apply -auto-approve "$(Pipeline.Workspace)/terraform-plan/tfplan"
                      
                      # Extract outputs
                      terraform output -json > "$(Build.ArtifactStagingDirectory)/terraform-outputs.json"
                      
                      echo "Deployment completed successfully"
                
                - task: PublishPipelineArtifact@1
                  displayName: 'Publish Terraform Outputs'
                  inputs:
                    targetPath: '$(Build.ArtifactStagingDirectory)/terraform-outputs.json'
                    artifact: 'terraform-outputs'
                    publishLocation: 'pipeline'

  # ========================================
  # STAGE 5: Post-Deployment Validation
  # ========================================
  - stage: PostDeploymentValidation
    displayName: 'Post-Deployment Validation'
    dependsOn: TerraformApply
    jobs:
      - job: ValidateDeployment
        displayName: 'Validate VM Deployment'
        steps:
          - checkout: self
          
          - task: DownloadPipelineArtifact@2
            displayName: 'Download Terraform Outputs'
            inputs:
              artifactName: 'terraform-outputs'
              targetPath: '$(Pipeline.Workspace)/terraform-outputs'
          
          - task: AzureCLI@2
            displayName: 'Verify VM Running Status'
            inputs:
              azureSubscription: $(azureServiceConnection)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "Reading Terraform outputs..."
                VM_ID=$(jq -r '.vm_id.value' $(Pipeline.Workspace)/terraform-outputs/terraform-outputs.json)
                VM_NAME=$(jq -r '.vm_name.value' $(Pipeline.Workspace)/terraform-outputs/terraform-outputs.json)
                
                echo "Checking VM status for: $VM_NAME"
                
                VM_STATUS=$(az vm get-instance-view --ids "$VM_ID" --query "instanceView.statuses[?starts_with(code, 'PowerState/')].displayStatus" -o tsv)
                
                echo "VM Status: $VM_STATUS"
                
                if [[ "$VM_STATUS" != *"running"* ]]; then
                  echo "##vso[task.logissue type=error]VM is not running!"
                  exit 1
                fi
                
                echo "VM is running successfully"
          
          - task: AzureCLI@2
            displayName: 'Verify Monitoring Agents'
            inputs:
              azureSubscription: $(azureServiceConnection)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                VM_ID=$(jq -r '.vm_id.value' $(Pipeline.Workspace)/terraform-outputs/terraform-outputs.json)
                
                echo "Checking VM extensions..."
                EXTENSIONS=$(az vm extension list --ids "$VM_ID" --query "[].name" -o tsv)
                
                echo "Installed extensions: $EXTENSIONS"
                
                if [[ ! "$EXTENSIONS" =~ "AzureMonitorWindowsAgent" ]] && [[ ! "$EXTENSIONS" =~ "AzureMonitorLinuxAgent" ]]; then
                  echo "##vso[task.logissue type=warning]Azure Monitor Agent not found"
                fi
                
                echo "Extension verification completed"
          
          - task: PowerShell@2
            displayName: 'Run Connectivity Tests'
            inputs:
              targetType: 'inline'
              script: |
                Write-Host "Reading Terraform outputs..."
                $outputs = Get-Content "$(Pipeline.Workspace)/terraform-outputs/terraform-outputs.json" | ConvertFrom-Json
                
                $vmPrivateIp = $outputs.vm_private_ip.value
                $vmName = $outputs.vm_name.value
                
                Write-Host "VM Private IP: $vmPrivateIp"
                Write-Host "VM Name: $vmName"
                
                # Test DNS resolution (if domain joined)
                if ($outputs.vm_fqdn.value) {
                  $fqdn = $outputs.vm_fqdn.value
                  Write-Host "Testing DNS resolution for: $fqdn"
                  
                  try {
                    $resolved = Resolve-DnsName $fqdn -ErrorAction Stop
                    Write-Host "DNS resolution successful: $($resolved.IPAddress)"
                  }
                  catch {
                    Write-Warning "DNS resolution failed: $_"
                  }
                }
                
                Write-Host "Connectivity tests completed"

  # ========================================
  # STAGE 6: Notification
  # ========================================
  - stage: Notification
    displayName: 'Send Notifications'
    dependsOn: PostDeploymentValidation
    condition: always()
    jobs:
      - job: NotifyStakeholders
        displayName: 'Notify Stakeholders'
        steps:
          - checkout: self
          
          - task: DownloadPipelineArtifact@2
            displayName: 'Download Terraform Outputs'
            condition: succeeded()
            inputs:
              artifactName: 'terraform-outputs'
              targetPath: '$(Pipeline.Workspace)/terraform-outputs'
          
          - task: PowerShell@2
            displayName: 'Update ServiceNow - Success'
            condition: succeeded()
            inputs:
              targetType: 'filePath'
              filePath: '$(System.DefaultWorkingDirectory)/scripts/powershell/Update-ServiceNowTicket.ps1'
              arguments: >
                -TicketNumber "$(SERVICENOW_TICKET)"
                -Status "Deployed Successfully"
                -Comments "VM deployed successfully via Terraform. All post-deployment validations passed."
                -ServiceNowInstance "$(SERVICENOW_INSTANCE)"
                -ServiceNowUser "$(SERVICENOW_USER)"
                -ServiceNowPassword "$(SERVICENOW_PASSWORD)"
                -OutputJsonPath "$(Pipeline.Workspace)/terraform-outputs/terraform-outputs.json"
          
          - task: PowerShell@2
            displayName: 'Update ServiceNow - Failure'
            condition: failed()
            inputs:
              targetType: 'filePath'
              filePath: '$(System.DefaultWorkingDirectory)/scripts/powershell/Update-ServiceNowTicket.ps1'
              arguments: >
                -TicketNumber "$(SERVICENOW_TICKET)"
                -Status "Deployment Failed"
                -Comments "VM deployment failed. Please check pipeline logs for details. Build: $(Build.BuildNumber)"
                -ServiceNowInstance "$(SERVICENOW_INSTANCE)"
                -ServiceNowUser "$(SERVICENOW_USER)"
                -ServiceNowPassword "$(SERVICENOW_PASSWORD)"
          
          - task: SendEmail@1
            displayName: 'Send Success Email'
            condition: succeeded()
            inputs:
              To: '$(NOTIFICATION_EMAIL)'
              From: 'azure-automation@Your Organization.com'
              Subject: '[SUCCESS] VM Deployment Completed - $(TF_VAR_vm_name)'
              Body: |
                VM deployment completed successfully.
                
                VM Name: $(TF_VAR_vm_name)
                Environment: $(Build.SourceBranchName)
                Build: $(Build.BuildNumber)
                
                Please check ServiceNow ticket $(SERVICENOW_TICKET) for details.
          
          - task: SendEmail@1
            displayName: 'Send Failure Email'
            condition: failed()
            inputs:
              To: '$(NOTIFICATION_EMAIL)'
              From: 'azure-automation@Your Organization.com'
              Subject: '[FAILED] VM Deployment Failed - $(TF_VAR_vm_name)'
              Body: |
                VM deployment failed.
                
                VM Name: $(TF_VAR_vm_name)
                Environment: $(Build.SourceBranchName)
                Build: $(Build.BuildNumber)
                
                Please check pipeline logs and ServiceNow ticket $(SERVICENOW_TICKET) for details.
