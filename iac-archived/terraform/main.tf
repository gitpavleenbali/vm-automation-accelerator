# Main Terraform Configuration for VM Deployment
# This root module orchestrat  ) : timeadd(timestamp(), "8760h")
}

# Auto-generate admin password if needed (AVM pattern with backward compatibility)
resource "random_password" "vm_admin" {
  count            = local.should_generate_password ? 1 : 0l child modules for VM provisioning

locals {
  # Common tags applied to all resources
  common_tags = merge(
    var.tags,
    {
      ManagedBy       = "Terraform"
      Environment     = var.environment
      DeploymentDate  = timestamp()
      TerraformRepo   = "vm-automation-accelerator"
      StateKey        = "vm-automation/${var.environment}/terraform.tfstate"
    }
  )
  
  # Resource naming convention: <resource_type>-<name>-<environment>-<location>-<instance>
  resource_suffix = "${var.environment}-${var.location_short}-${format("%03d", var.instance_id)}"
}

# Data sources for existing resources
data "azurerm_resource_group" "main" {
  name = var.resource_group_name
}

data "azurerm_subnet" "vm" {
  name                 = var.subnet_name
  virtual_network_name = var.vnet_name
  resource_group_name  = var.network_resource_group_name
}

data "azurerm_log_analytics_workspace" "main" {
  name                = var.log_analytics_workspace_name
  resource_group_name = var.log_analytics_resource_group_name
}

data "azurerm_recovery_services_vault" "main" {
  count               = var.enable_backup ? 1 : 0
  name                = var.recovery_vault_name
  resource_group_name = var.recovery_vault_resource_group_name
}

data "azurerm_key_vault" "main" {
  name                = var.key_vault_name
  resource_group_name = var.key_vault_resource_group_name
}

# ===========================
# Credential Management (AVM Pattern)
# ===========================

locals {
  # Determine credential source: account_credentials (new) or legacy variables
  use_account_credentials = var.account_credentials != null
  
  # Admin username with fallback to legacy
  admin_username = local.use_account_credentials ? var.account_credentials.admin_credentials.username : var.admin_username
  
  # Determine if we should generate credentials
  should_generate_password = local.use_account_credentials ? (
    var.account_credentials.admin_credentials.generate_admin_password_or_ssh_key && 
    var.account_credentials.admin_credentials.password == null
  ) : (var.admin_password == null)
  
  # Determine if we should store in Key Vault
  should_store_in_keyvault = local.use_account_credentials ? (
    var.account_credentials.key_vault_configuration != null && local.should_generate_password
  ) : local.should_generate_password
  
  # Key Vault ID for credential storage
  credential_key_vault_id = local.use_account_credentials ? (
    var.account_credentials.key_vault_configuration != null ? var.account_credentials.key_vault_configuration.resource_id : data.azurerm_key_vault.main.id
  ) : data.azurerm_key_vault.main.id
  
  # Secret expiration date (1 year from now if not specified)
  secret_expiration = local.use_account_credentials && var.account_credentials.key_vault_configuration != null ? (
    var.account_credentials.key_vault_configuration.secret_expiration_date != null ? 
    var.account_credentials.key_vault_configuration.secret_expiration_date : 
    timeadd(timestamp(), \"8760h\")  # 1 year
  ) : timeadd(timestamp(), \"8760h\")

# Random password generation for VM admin (stored in Key Vault)
resource "random_password" "vm_admin" {
  count            = var.admin_password == null ? 1 : 0
  length           = 24
  special          = true
  override_special = "!@#$%^&*()_+"
  min_lower        = 2
  min_upper        = 2
  min_numeric      = 2
  min_special      = 2
}

# Store auto-generated admin password in Key Vault (AVM pattern)
resource "azurerm_key_vault_secret" "vm_admin_password" {
  count        = local.should_store_in_keyvault ? 1 : 0
  name         = "${var.vm_name}-admin-password"
  value        = random_password.vm_admin[0].result
  key_vault_id = local.credential_key_vault_id
  
  content_type    = "VM Admin Password - Auto-generated by Terraform (AVM Pattern)"
  expiration_date = local.secret_expiration
  
  tags = merge(local.common_tags, {
    CredentialType = "AdminPassword"
    AutoGenerated  = "true"
    VMName         = var.vm_name
  })
}

# Network Security Group with Firewall Change Request (FCR) rules
module "network_security" {
  source = "./modules/network-security"
  
  nsg_name            = "nsg-${var.vm_name}-${local.resource_suffix}"
  resource_group_name = data.azurerm_resource_group.main.name
  location            = data.azurerm_resource_group.main.location
  
  # Allow Active Directory and DNS traffic (FCR rules)
  enable_ad_rules  = var.enable_ad_dns_rules
  enable_dns_rules = var.enable_ad_dns_rules
  
  # Custom security rules
  custom_rules = var.custom_nsg_rules
  
  tags = local.common_tags
}

# Network Interface with optional Public IP
module "network_interface" {
  source = "./modules/network-interface"
  
  nic_name                      = "nic-${var.vm_name}-${local.resource_suffix}"
  resource_group_name           = data.azurerm_resource_group.main.name
  location                      = data.azurerm_resource_group.main.location
  subnet_id                     = data.azurerm_subnet.vm.id
  network_security_group_id     = module.network_security.nsg_id
  
  # IP Configuration
  private_ip_address_allocation = var.private_ip_address_allocation
  private_ip_address            = var.private_ip_address
  enable_public_ip              = var.enable_public_ip
  public_ip_name                = var.enable_public_ip ? "pip-${var.vm_name}-${local.resource_suffix}" : null
  
  # Accelerated Networking
  enable_accelerated_networking = var.enable_accelerated_networking
  enable_ip_forwarding          = var.enable_ip_forwarding
  
  tags = local.common_tags
}

# Virtual Machine (Windows or Linux)
module "virtual_machine" {
  source = "./modules/compute"
  
  vm_name             = var.vm_name
  resource_group_name = data.azurerm_resource_group.main.name
  location            = data.azurerm_resource_group.main.location
  
  # VM Size and Configuration
  vm_size               = var.vm_size
  os_type               = var.os_type
  source_image_id       = var.source_image_id
  use_custom_image      = var.use_custom_image
  publisher             = var.publisher
  offer                 = var.offer
  sku                   = var.sku
  image_version         = var.image_version
  
  # Disk Configuration
  os_disk_size_gb           = var.os_disk_size_gb
  os_disk_storage_type      = var.os_disk_storage_type
  os_disk_caching           = var.os_disk_caching
  data_disks                = var.data_disks
  
  # Admin Credentials (AVM Pattern with backward compatibility)
  admin_username = local.admin_username
  admin_password = local.use_account_credentials ? (
    var.account_credentials.admin_credentials.password != null ? 
    var.account_credentials.admin_credentials.password : 
    (local.should_generate_password ? random_password.vm_admin[0].result : null)
  ) : (
    var.admin_password != null ? var.admin_password : random_password.vm_admin[0].result
  )
  ssh_public_key = local.use_account_credentials ? (
    length(var.account_credentials.admin_credentials.ssh_keys) > 0 ? var.account_credentials.admin_credentials.ssh_keys[0] : null
  ) : var.ssh_public_key
  
  # Network
  network_interface_ids = [module.network_interface.nic_id]
  
  # Security (AVM Best Practices)
  encryption_at_host_enabled      = var.encryption_at_host_enabled
  disk_encryption_set_id          = var.disk_encryption_set_id
  enable_boot_diagnostics         = var.enable_boot_diagnostics
  boot_diagnostics_storage_uri    = var.boot_diagnostics_storage_uri
  enable_secure_boot              = var.enable_secure_boot
  enable_vtpm                     = var.enable_vtpm
  
  # Managed Identity (AVM Pattern)
  managed_identities = {
    system_assigned            = var.enable_system_assigned_identity
    user_assigned_resource_ids = var.user_assigned_identity_ids
  }
  
  # RBAC Role Assignments
  role_assignments                       = var.role_assignments
  role_assignments_system_managed_identity = var.role_assignments_system_managed_identity
  
  # Diagnostic Settings (AVM Pattern)
  diagnostic_settings = var.diagnostic_settings
  
  # Availability
  availability_zone = var.availability_zone
  
  tags = local.common_tags
}

# Azure Monitor Agent and Dependency Agent
module "monitoring" {
  source = "./modules/monitoring"
  
  vm_id                         = module.virtual_machine.vm_id
  vm_name                       = module.virtual_machine.vm_name
  resource_group_name           = data.azurerm_resource_group.main.name
  location                      = data.azurerm_resource_group.main.location
  os_type                       = var.os_type
  
  # Log Analytics
  log_analytics_workspace_id    = data.azurerm_log_analytics_workspace.main.id
  log_analytics_workspace_key   = data.azurerm_log_analytics_workspace.main.primary_shared_key
  
  # Data Collection Rules
  enable_performance_counters   = var.enable_performance_monitoring
  enable_event_logs             = var.enable_event_log_collection
  enable_vm_insights            = var.enable_vm_insights
  
  tags = local.common_tags
  
  depends_on = [module.virtual_machine]
}

# Domain Join Extension (Windows only)
module "domain_join" {
  source = "./modules/domain-join"
  count  = var.os_type == "Windows" && var.enable_domain_join ? 1 : 0
  
  vm_id               = module.virtual_machine.vm_id
  vm_name             = module.virtual_machine.vm_name
  resource_group_name = data.azurerm_resource_group.main.name
  location            = data.azurerm_resource_group.main.location
  
  domain_name         = var.domain_name
  domain_ou_path      = var.domain_ou_path
  domain_join_account = var.domain_join_account
  domain_join_password = var.domain_join_password
  
  tags = local.common_tags
  
  depends_on = [module.monitoring]
}

# VM Hardening via Custom Script Extension
module "hardening" {
  source = "./modules/hardening"
  
  vm_id               = module.virtual_machine.vm_id
  vm_name             = module.virtual_machine.vm_name
  resource_group_name = data.azurerm_resource_group.main.name
  location            = data.azurerm_resource_group.main.location
  os_type             = var.os_type
  
  # Hardening Configuration
  hardening_script_url      = var.hardening_script_url
  hardening_script_name     = var.hardening_script_name
  hardening_script_args     = var.hardening_script_args
  storage_account_name      = var.scripts_storage_account_name
  storage_account_key       = var.scripts_storage_account_key
  
  tags = local.common_tags
  
  depends_on = [module.domain_join]
}

# Azure Backup Configuration (AVM Pattern)
# Using azapi_resource for backup_intent API with disk LUN filtering support
locals {
  # Calculate backup extended properties for disk filtering
  backup_extended_properties = var.enable_backup ? (
    try(length(var.backup_exclude_disk_luns) > 0, false) ? {
      extendedProperties = {
        diskExclusionProperties = {
          diskLunList     = var.backup_exclude_disk_luns
          isInclusionList = false
        }
      }
    } : try(length(var.backup_include_disk_luns) > 0, false) ? {
      extendedProperties = {
        diskExclusionProperties = {
          diskLunList     = var.backup_include_disk_luns
          isInclusionList = true
        }
      }
    } : {}
  ) : {}
  
  # Base backup body properties
  backup_body_properties = var.enable_backup ? merge(
    {
      protectedItemType = "Microsoft.Compute/virtualMachines"
      sourceResourceId  = module.virtual_machine.vm_id
      policyId          = var.backup_policy_id
      containerName     = "iaasvmcontainerv2;${data.azurerm_resource_group.main.name};${var.vm_name}"
      policyName        = basename(var.backup_policy_id)
    },
    local.backup_extended_properties
  ) : {}
}

resource "azapi_resource" "backup_intent" {
  count     = var.enable_backup ? 1 : 0
  type      = "Microsoft.RecoveryServices/vaults/backupFabrics/protectionContainers/protectedItems@2024-10-01"
  name      = "VM;iaasvmcontainerv2;${data.azurerm_resource_group.main.name};${var.vm_name}"
  parent_id = "${data.azurerm_recovery_services_vault.main[0].id}/backupFabrics/Azure/protectionContainers/iaasvmcontainer;iaasvmcontainerv2;${data.azurerm_resource_group.main.name};${var.vm_name}"
  
  body = jsonencode({
    properties = local.backup_body_properties
  })
  
  # AVM telemetry headers for module usage tracking
  create_headers         = var.enable_telemetry ? { "User-Agent" : local.avm_azapi_header } : null
  delete_headers         = var.enable_telemetry ? { "User-Agent" : local.avm_azapi_header } : null
  read_headers           = var.enable_telemetry ? { "User-Agent" : local.avm_azapi_header } : null
  update_headers         = var.enable_telemetry ? { "User-Agent" : local.avm_azapi_header } : null
  response_export_values = ["*"]
  
  depends_on = [module.hardening]
}

# Azure Site Recovery (Optional for hot VMs)
module "site_recovery" {
  source = "./modules/site-recovery"
  count  = var.enable_asr ? 1 : 0
  
  vm_id                           = module.virtual_machine.vm_id
  vm_name                         = module.virtual_machine.vm_name
  source_resource_group_name      = data.azurerm_resource_group.main.name
  source_location                 = data.azurerm_resource_group.main.location
  
  # DR Configuration
  target_resource_group_name      = var.asr_target_resource_group_name
  target_location                 = var.asr_target_location
  recovery_vault_name             = var.asr_recovery_vault_name
  recovery_vault_resource_group   = var.asr_recovery_vault_resource_group
  replication_policy_name         = var.asr_replication_policy_name
  
  tags = local.common_tags
  
  depends_on = [azapi_resource.backup_intent]
}
