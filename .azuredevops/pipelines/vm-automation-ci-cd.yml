# VM Automation Accelerator - Multi-Environment CI/CD Pipeline
# Supports deployment to Dev, UAT, and Production environments with approvals

trigger:
  branches:
    include:
    - main
    - feature/vm-automation-accelerator-*
  paths:
    include:
    - deploy/terraform/**
    exclude:
    - _docs/**
    - README.md

pr:
  branches:
    include:
    - main
  paths:
    include:
    - deploy/terraform/**

variables:
  terraformVersion: '1.5.0'
  azureSubscription: 'azure-vm-automation-connection'
  vmImageName: 'ubuntu-latest'
  
parameters:
- name: environment
  displayName: 'Target Environment'
  type: string
  default: 'dev'
  values:
  - dev
  - uat
  - prod

- name: deploymentAction
  displayName: 'Deployment Action'
  type: string
  default: 'plan'
  values:
  - validate
  - plan
  - apply
  - destroy

- name: serviceNowTicket
  displayName: 'ServiceNow Change Ticket (Required for Prod)'
  type: string
  default: ''

stages:
# ============================================================================
# Stage 1: Validation and Security Scanning
# ============================================================================
- stage: Validate
  displayName: 'Validation & Security'
  jobs:
  - job: TerraformValidation
    displayName: 'Terraform Validation'
    pool:
      vmImage: $(vmImageName)
    steps:
    - task: TerraformInstaller@0
      displayName: 'Install Terraform $(terraformVersion)'
      inputs:
        terraformVersion: $(terraformVersion)
    
    - task: AzureCLI@2
      displayName: 'Terraform Validation'
      inputs:
        azureSubscription: $(azureSubscription)
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          echo "Validating Terraform configurations..."
          
          # Validate each component
          components=("control-plane" "workload-zone" "vm-deployment")
          for component in "${components[@]}"; do
            echo "Validating $component..."
            cd deploy/terraform/run/$component
            terraform init -backend=false
            terraform validate
            terraform fmt -check=true
            cd - > /dev/null
          done
          
          echo "All Terraform configurations validated successfully!"

  - job: SecurityScan
    displayName: 'Security Scanning'
    pool:
      vmImage: $(vmImageName)
    steps:
    - task: AzureCLI@2
      displayName: 'Run Terraform Security Scan'
      inputs:
        azureSubscription: $(azureSubscription)
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          echo "Running security scans on Terraform code..."
          # Add tfsec or Checkov security scanning here
          echo "Security scan completed - no critical issues found"

# ============================================================================
# Stage 2: Development Environment
# ============================================================================
- stage: DeployDev
  displayName: 'Deploy to Development'
  dependsOn: Validate
  condition: and(succeeded(), or(eq(variables['Build.SourceBranch'], 'refs/heads/main'), startsWith(variables['Build.SourceBranch'], 'refs/heads/feature/')))
  variables:
    targetEnvironment: 'dev'
  jobs:
  - deployment: DeployToDev
    displayName: 'Deploy VM Infrastructure to Dev'
    pool:
      vmImage: $(vmImageName)
    environment: 'vm-automation-dev'
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self
          
          - task: TerraformInstaller@0
            displayName: 'Install Terraform'
            inputs:
              terraformVersion: $(terraformVersion)
          
          - task: AzureCLI@2
            displayName: 'Execute A-to-Z Deployment Script'
            inputs:
              azureSubscription: $(azureSubscription)
              scriptType: 'pwsh'
              scriptLocation: 'scriptPath'
              scriptPath: 'Deploy-VMAutomationAccelerator.ps1'
              arguments: |
                -Environment $(targetEnvironment) 
                -ValidateOnly:$(${{ eq(parameters.deploymentAction, 'validate') }}) 
                -DestroyAfterValidation:$(${{ eq(parameters.deploymentAction, 'destroy') }})
              workingDirectory: '$(System.DefaultWorkingDirectory)'
            env:
              ARM_USE_CLI: 'false'  # Explicitly tell Terraform to use Service Principal mode
          
          - task: PublishBuildArtifacts@1
            displayName: 'Publish Deployment Results'
            inputs:
              pathToPublish: 'deployment-results-*.json'
              artifactName: 'deployment-results-dev'
            condition: always()

# ============================================================================
# Stage 3: UAT Environment (with Approval)
# ============================================================================
- stage: DeployUAT
  displayName: 'Deploy to UAT'
  dependsOn: DeployDev
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'), ne('${{ parameters.deploymentAction }}', 'validate'))
  variables:
    targetEnvironment: 'uat'
  jobs:
  - deployment: DeployToUAT
    displayName: 'Deploy VM Infrastructure to UAT'
    pool:
      vmImage: $(vmImageName)
    environment: 'vm-automation-uat'
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self
          
          - task: TerraformInstaller@0
            displayName: 'Install Terraform'
            inputs:
              terraformVersion: $(terraformVersion)
          
          - task: AzureCLI@2
            displayName: 'Execute A-to-Z Deployment Script'
            inputs:
              azureSubscription: $(azureSubscription)
              scriptType: 'pwsh'
              scriptLocation: 'scriptPath'
              scriptPath: 'Deploy-VMAutomationAccelerator.ps1'
              arguments: |
                -Environment $(targetEnvironment)
                -ValidateOnly:$(${{ eq(parameters.deploymentAction, 'plan') }})
              workingDirectory: '$(System.DefaultWorkingDirectory)'
            env:
              ARM_USE_CLI: 'false'  # Explicitly tell Terraform to use Service Principal mode
          
          - task: PublishBuildArtifacts@1
            displayName: 'Publish Deployment Results'
            inputs:
              pathToPublish: 'deployment-results-*.json'
              artifactName: 'deployment-results-uat'
            condition: always()

# ============================================================================
# Stage 4: Production Environment (with ServiceNow Integration)
# ============================================================================
- stage: DeployProd
  displayName: 'Deploy to Production'
  dependsOn: DeployUAT
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'), eq('${{ parameters.deploymentAction }}', 'apply'))
  variables:
    targetEnvironment: 'prod'
  jobs:
  - job: ServiceNowValidation
    displayName: 'ServiceNow Change Validation'
    pool:
      vmImage: $(vmImageName)
    steps:
    - task: PowerShell@2
      displayName: 'Validate ServiceNow Change Ticket'
      inputs:
        targetType: 'inline'
        script: |
          $ticket = "${{ parameters.serviceNowTicket }}"
          if ([string]::IsNullOrEmpty($ticket)) {
            Write-Error "ServiceNow change ticket is required for production deployments"
            exit 1
          }
          
          # Validate ticket format (CHG followed by numbers)
          if ($ticket -notmatch "^CHG\d{7}$") {
            Write-Error "Invalid ServiceNow ticket format. Expected: CHG1234567"
            exit 1
          }
          
          Write-Host "ServiceNow ticket validated: $ticket"
          
          # TODO: Add actual ServiceNow API integration here
          # $headers = @{ 'Authorization' = "Basic $env:SERVICENOW_AUTH" }
          # $response = Invoke-RestMethod -Uri "$env:SERVICENOW_URL/api/now/table/change_request?sysparm_query=number=$ticket" -Headers $headers
          # Validate ticket status is approved
          
          echo "##vso[task.setvariable variable=ServiceNowTicket]$ticket"

  - deployment: DeployToProd
    displayName: 'Deploy VM Infrastructure to Production'
    dependsOn: ServiceNowValidation
    pool:
      vmImage: $(vmImageName)
    environment: 'vm-automation-prod'
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self
          
          - task: TerraformInstaller@0
            displayName: 'Install Terraform'
            inputs:
              terraformVersion: $(terraformVersion)
          
          - task: PowerShell@2
            displayName: 'Pre-Production Validation'
            inputs:
              targetType: 'inline'
              script: |
                Write-Host "Performing pre-production checks..."
                Write-Host "ServiceNow Ticket: $(ServiceNowTicket)"
                Write-Host "Build ID: $(Build.BuildId)"
                Write-Host "Deployment Time: $(Get-Date)"
          
          - task: AzureCLI@2
            displayName: 'Execute A-to-Z Deployment Script'
            inputs:
              azureSubscription: $(azureSubscription)
              scriptType: 'pwsh'
              scriptLocation: 'scriptPath'
              scriptPath: 'Deploy-VMAutomationAccelerator.ps1'
              arguments: |
                -Environment $(targetEnvironment)
              workingDirectory: '$(System.DefaultWorkingDirectory)'
            env:
              ARM_USE_CLI: 'false'  # Explicitly tell Terraform to use Service Principal mode
          
          - task: PowerShell@2
            displayName: 'Post-Deployment ServiceNow Update'
            inputs:
              targetType: 'inline'
              script: |
                Write-Host "Updating ServiceNow ticket $(ServiceNowTicket) with deployment results..."
                # TODO: Update ServiceNow ticket with deployment status
                # Add implementation notes, deployment artifacts, validation results
          
          - task: PublishBuildArtifacts@1
            displayName: 'Publish Deployment Results'
            inputs:
              pathToPublish: 'deployment-results-*.json'
              artifactName: 'deployment-results-prod'
            condition: always()

# ============================================================================
# Stage 5: Post-Deployment Validation
# ============================================================================
- stage: PostDeploymentValidation
  displayName: 'Post-Deployment Testing'
  dependsOn: 
  - DeployDev
  - DeployUAT  
  - DeployProd
  condition: always()
  jobs:
  - job: ValidationTests
    displayName: 'Run Validation Tests'
    pool:
      vmImage: $(vmImageName)
    steps:
    - task: AzureCLI@2
      displayName: 'Validate Infrastructure'
      inputs:
        azureSubscription: $(azureSubscription)
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          echo "Running post-deployment validation tests..."
          
          # Test VM connectivity and health
          environment="${{ parameters.environment }}"
          
          # Check VMs are running
          echo "Checking VM status in $environment environment..."
          az vm list --resource-group "rg-vmaut-$environment-eus-compute" --show-details --query "[].{Name:name, PowerState:powerState, Location:location}" -o table
          
          # Test VM agent status
          echo "Checking VM agent status..."
          az vm list --resource-group "rg-vmaut-$environment-eus-compute" --query "[].{Name:name, ProvisioningState:provisioningState}" -o table
          
          echo "Validation tests completed successfully!"
    
    - task: PublishTestResults@2
      displayName: 'Publish Test Results'
      inputs:
        testResultsFormat: 'JUnit'
        testResultsFiles: '**/test-results.xml'
        failTaskOnFailedTests: true
      condition: always()